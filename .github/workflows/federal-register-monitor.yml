name: Federal Register Monitor

on:
  schedule:
    - cron: '15 * * * *'
  workflow_dispatch:

jobs:
  check-federal-register:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Check Federal Register and agency websites
        run: |
          cat << 'EOF' > check-federal-register.js
          const fs = require('fs');
          const https = require('https');

          const SEARCH_TERMS = ['GENIUS Act', 'stablecoin', 'payment stablecoin'];
          const SEEN_FILE = 'seen-documents.json';

          const AGENCY_FEEDS = [
            { name: 'OCC News Releases', url: 'https://www.occ.gov/static/news-issuances/ews/occ-news-releases.xml', agency: 'OCC' },
            { name: 'OCC Bulletins', url: 'https://www.occ.gov/static/news-issuances/ews/occ-bulletins.xml', agency: 'OCC' },
            { name: 'FDIC Press Releases', url: 'https://www.fdic.gov/news/press-releases/index.xml', agency: 'FDIC' },
            { name: 'Federal Reserve Press Releases', url: 'https://www.federalreserve.gov/feeds/press_all.xml', agency: 'Federal Reserve' },
            { name: 'NCUA News', url: 'https://ncua.gov/newsroom/press-release/rss.xml', agency: 'NCUA' }
          ];

          const KEYWORDS = ['genius act', 'stablecoin', 'payment stablecoin', 'digital asset', 'crypto', 'stable coin'];

          function fetchUrl(url) {
            return new Promise((resolve, reject) => {
              const client = url.startsWith('https') ? https : require('http');
              client.get(url, { headers: { 'User-Agent': 'GENIUS-Act-Tracker/1.0' } }, (res) => {
                if (res.statusCode >= 300 && res.statusCode < 400 && res.headers.location) {
                  return fetchUrl(res.headers.location).then(resolve).catch(reject);
                }
                let data = '';
                res.on('data', chunk => data += chunk);
                res.on('end', () => resolve(data));
                res.on('error', reject);
              }).on('error', reject);
            });
          }

          function parseXMLItems(xml) {
            const items = [];
            const re = /<item>([\s\S]*?)<\/item>/gi;
            let m;
            while ((m = re.exec(xml)) !== null) {
              const x = m[1];
              const title = (x.match(/<title[^>]*>([\s\S]*?)<\/title>/) || [])[1] || '';
              const link = (x.match(/<link[^>]*>([\s\S]*?)<\/link>/) || [])[1] || '';
              const pubDate = (x.match(/<pubDate>([\s\S]*?)<\/pubDate>/) || [])[1] || '';
              const desc = (x.match(/<description>([\s\S]*?)<\/description>/) || [])[1] || '';
              items.push({
                title: title.replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1').trim(),
                link: link.replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1').trim(),
                pubDate: pubDate.trim(),
                description: desc.replace(/<!\[CDATA\[(.*?)\]\]>/g, '$1').replace(/<[^>]+>/g, '').trim()
              });
            }
            return items;
          }

          function isRelevant(item) {
            const text = (item.title + ' ' + item.description).toLowerCase();
            return KEYWORDS.some(kw => text.includes(kw));
          }

          async function searchFR() {
            const base = 'https://www.federalregister.gov/api/v1/documents.json';
            const all = [];
            for (const term of SEARCH_TERMS) {
              try {
                const raw = await fetchUrl(base + '?conditions[term]=' + encodeURIComponent(term) + '&per_page=20&order=newest');
                const resp = JSON.parse(raw);
                if (resp.results) {
                  all.push(...resp.results.map(d => ({
                    id: d.document_number, title: d.title, type: d.type || 'Document',
                    agency: (d.agencies && d.agencies[0] && d.agencies[0].name) || 'Unknown',
                    publication_date: d.publication_date, url: d.html_url || '', source: 'Federal Register'
                  })));
                }
              } catch (e) { console.error('FR error:', e.message); }
            }
            return all;
          }

          async function searchAgencies() {
            const all = [];
            for (const feed of AGENCY_FEEDS) {
              try {
                const raw = await fetchUrl(feed.url);
                const items = parseXMLItems(raw).filter(isRelevant);
                for (const item of items) {
                  all.push({
                    id: item.link || item.title, title: item.title, type: 'Agency Announcement',
                    agency: feed.agency,
                    publication_date: item.pubDate ? new Date(item.pubDate).toISOString().split('T')[0] : 'Unknown',
                    url: item.link, source: feed.name
                  });
                }
              } catch (e) { console.error(feed.name + ' error:', e.message); }
            }
            return all;
          }

          async function main() {
            let seenData = { seenDocuments: [] };
            try {
              seenData = JSON.parse(fs.readFileSync(SEEN_FILE, 'utf8'));
              if (!seenData.seenDocuments) seenData.seenDocuments = [];
            } catch (e) { console.log('Creating new seen-documents.json'); }

            const seenIds = new Set(seenData.seenDocuments.map(d => d.document_number || d.id));
            const [frDocs, agDocs] = await Promise.all([searchFR(), searchAgencies()]);
            const unique = {};
            for (const d of [...frDocs, ...agDocs]) { if (d.id && !unique[d.id]) unique[d.id] = d; }
            const docs = Object.values(unique);
            console.log('Found ' + frDocs.length + ' FR + ' + agDocs.length + ' agency docs (' + docs.length + ' unique)');

            const newDocs = docs.filter(d => !seenIds.has(d.id));
            console.log('Found ' + newDocs.length + ' new documents');

            if (newDocs.length > 0) {
              const today = new Date().toISOString().split('T')[0];
              for (const doc of newDocs) {
                seenData.seenDocuments.push({
                  document_number: doc.id, title: doc.title, type: doc.type,
                  agency: doc.agency, publication_date: doc.publication_date,
                  url: doc.url, source: doc.source, first_seen: today
                });
              }
              seenData.lastChecked = new Date().toISOString();
              fs.writeFileSync(SEEN_FILE, JSON.stringify(seenData, null, 2));

              var html = fs.readFileSync('index.html', 'utf8');
              var todayFmt = new Date().toLocaleDateString('en-US', {
                year: 'numeric', month: 'long', day: 'numeric', timeZone: 'America/New_York'
              });
              html = html.replace(/<span id="lastUpdated">.*?<\/span>/, '<span id="lastUpdated">' + todayFmt + '</span>');
              fs.writeFileSync('index.html', html);

              console.log('New documents:');
              newDocs.forEach(d => console.log('- [' + d.source + '] ' + d.title + ' (' + d.agency + ')'));
              fs.writeFileSync('has-updates.txt', 'true');
              fs.writeFileSync('new-docs.json', JSON.stringify(newDocs, null, 2));
            } else {
              console.log('No new documents found');
            }
          }
          main().catch(e => { console.error('Error:', e); process.exit(1); });
          EOF

          node check-federal-register.js
          rm check-federal-register.js

      - name: Check for changes
        id: changes
        run: |
          if [ -f has-updates.txt ]; then
            echo "has_changes=true" >> $GITHUB_OUTPUT
            rm has-updates.txt
          else
            echo "has_changes=false" >> $GITHUB_OUTPUT
          fi

      - name: Commit and push updates
        if: steps.changes.outputs.has_changes == 'true'
        run: |
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          git add seen-documents.json index.html
          git commit -m "Auto-update: New Federal Register/agency documents"
          git push

      - name: Build Slack message
        if: steps.changes.outputs.has_changes == 'true' && env.SLACK_WEBHOOK_URL != ''
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          cat << 'EOF' > build-slack-msg.js
          const fs = require('fs');
          const docs = JSON.parse(fs.readFileSync('new-docs.json', 'utf8'));
          let text = '\ud83d\udd14 *New GENIUS Act documents found:*\n\n';
          docs.forEach(d => {
            text += '\ud83d\udcc4 *' + d.title + '*\n';
            text += '\u2022 Source: ' + d.source + '\n';
            text += '\u2022 Agency: ' + d.agency + '\n';
            text += '\u2022 Published: ' + d.publication_date + '\n';
            if (d.url) text += '\u2022 <' + d.url + '|View document>\n';
            text += '\n';
          });
          fs.writeFileSync('slack-payload.json', JSON.stringify({text: text}));
          EOF
          node build-slack-msg.js
          curl -X POST -H 'Content-type: application/json' -d @slack-payload.json "$SLACK_WEBHOOK_URL"
          rm -f new-docs.json slack-payload.json build-slack-msg.js
